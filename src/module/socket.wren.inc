// Please do not edit this file. It has been generated automatically
// from `src/module/socket.wren` using `util/wren_to_c_string.py`

static const char* socketModuleSource =
"import \"scheduler\" for Scheduler\n"
"\n"
"class Socket {\n"
"}\n"
"\n"
"// foreign class TCPServer is Base {\n"
"//     construct new(ip, port) {\n"
"//             _ip = ip\n"
"//             _port = port\n"
"//         }\n"
"//     listen=(handler) {\n"
"//         _handler = handler\n"
"//     }\n"
"//     serve() {\n"
"//         serve_(_ip,_port)\n"
"//     }\n"
"\n"
"//     foreign serve_(ip,port)\n"
"// }\n"
"\n"
"class TCPServer {\n"
"    construct new(ip, port) {\n"
"        _ip = ip\n"
"        _port = port\n"
"        _connections = []\n"
"        _uv = UVServer.new(ip, port, this)\n"
"        _uv.delegate = this\n"
"    }\n"
"    #delegated\n"
"    newIncomingConnection() {\n"
"      var uvconn = UVConnection.new()\n"
"      if (_uv.accept(uvconn)) {\n"
"        var connection = Connection.new(uvconn)\n"
"        _connections.add(connection)\n"
"        onConnect.call(connection)\n"
"      } else {\n"
"        uvconn.close()\n"
"      }\n"
"    }\n"
"    onConnect=(fn) { _onConnect = fn }\n"
"    onConnect { _onConnect }\n"
"    serve() { _uv.listen_() }\n"
"    stop() { _uv.stop_() }\n"
"}\n"
"\n"
"class Connection {\n"
"    static Open { \"open\" }\n"
"    static Closed { \"closed\" }\n"
"\n"
"    construct new(uvconn) {\n"
"        System.print(\"new connection\")\n"
"        _uv = uvconn\n"
"        _uv.delegate = this\n"
"        _readBuffer = \"\"\n"
"        _status = Connection.Open\n"
"    }\n"
"    isClosed { _status == Connection.Closed }\n"
"    isOpen { _statuc == Connection.Open }\n"
"    writeLn(data) { _uv.write(\"%(data)\n\") }\n"
"    write(data) { _uv.write(\"%(data)\") }\n"
"    writeBytes(strData) { _uv.writeBytes(strData) }\n"
"    uv_ { _uv }\n"
"    close() { \n"
"        _uv.close() \n"
"        _status = Connection.Closed\n"
"    }\n"
"    // instantly returns the read buffer or null if there is nothing to read\n"
"    read() { \n"
"        if (_readBuffer.isEmpty) return null \n"
"        var result = _readBuffer\n"
"        _readBuffer = \"\"\n"
"        return result\n"
"    }\n"
"    // reads data and waits to it if there isn't any\n"
"    readWait() {\n"
"        if (_readBuffer.isEmpty) {\n"
"            _sleepingForRead = Fiber.current\n"
"            Scheduler.runNextScheduled_()\n"
"        }\n"
"        return read()\n"
"    }\n"
"\n"
"    #delegated\n"
"    dataReceived(data) {\n"
"        System.print(data.bytes.toList)\n"
"        _readBuffer = _readBuffer + data\n"
"        if (_sleepingForRead) { \n"
"            var fiber = _sleepingForRead    \n"
"            _sleepingForRead = null\n"
"            Scheduler.resume_(fiber) \n"
"        }\n"
"    }\n"
"}\n"
"\n"
"foreign class UVConnection {\n"
"    construct new() {}\n"
"    // delegates must provide:\n"
"    // - dataReceived\n"
"    foreign delegate=(d)\n"
"    foreign writeBytes(strData)\n"
"    foreign write(str)\n"
"    foreign close()\n"
"}\n"
"\n"
"foreign class UVServer {\n"
"    construct new(ip,port,serverWren) {}\n"
"    foreign accept(client)\n"
"    foreign listen_()\n"
"    foreign stop_()\n"
"    // delegates must provide:\n"
"    // - newIncomingConnection\n"
"    foreign delegate=(d)\n"
"}";
