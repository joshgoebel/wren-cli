// Please do not edit this file. It has been generated automatically
// from `src/module/network.wren` using `util/wren_to_c_string.py`

static const char* networkModuleSource =
"import \"scheduler\" for Scheduler\n"
"\n"
"class NetworkErrorType {\n"
"  static ECONNREFUSED { \"ECONNREFUSED\" }\n"
"  static TYPES { { \n"
"    61: NetworkErrorType.ECONNREFUSED\n"
"  } }\n"
"}\n"
"\n"
"class NetworkError {\n"
"  construct new(message, errCode) {\n"
"    message = message\n"
"    error = errCode.abs\n"
"  }\n"
"  static fromCode(err) { new(\"\", err) }\n"
"  error { _error }\n"
"  error=(e) { \n"
"    _error = e\n"
"    if (NetworkErrorType.TYPES.containsKey(_error)) {\n"
"      _message = NetworkErrorType.TYPES[_error]\n"
"    }\n"
"  }\n"
"  message { _message }\n"
"  message=(m) { _message = m }\n"
"  toString { \"NetworkError: %(message) (%(error))\" }\n"
"  // TODO: change back to simple Fiber.abort when we're on wren-essentials\n"
"  raise() {\n"
"    System.print(\"ABORT: \" + toString)\n"
"    Fiber.abort(this)\n"
"  }\n"
"}\n"
"\n"
"// rough idea borrowed from Nim\n"
"class Lock {\n"
"  construct new() { _fiber = null }\n"
"  wait() { \n"
"    _fiber = Fiber.current\n"
"    Scheduler.runNextScheduled_()\n"
"  }\n"
"  signal() { \n"
"    if (_fiber == null) return\n"
"\n"
"    var fb = _fiber\n"
"    _fiber = null\n"
"    Scheduler.resume_(fb) \n"
"  }\n"
"  signal(v) { \n"
"    if (_fiber == null) return\n"
"\n"
"    var fb = _fiber\n"
"    _fiber = null\n"
"    Scheduler.resume_(fb, v) \n"
"  }\n"
"}\n"
"\n"
"class TCPServer {\n"
"    construct new(ip, port) {\n"
"        _ip = ip\n"
"        _port = port\n"
"        _uv = UVServer.new(ip, port)\n"
"        _uv.delegate = this\n"
"    }\n"
"    #delegated\n"
"    newIncomingConnection() {\n"
"      var uvconn = UVConnection.new()\n"
"      if (_uv.accept(uvconn)) {\n"
"        var connection = Connection.new(uvconn)\n"
"        onConnect.call(connection)\n"
"      } else {\n"
"        uvconn.close()\n"
"      }\n"
"    }\n"
"    onConnect=(fn) { _onConnect = fn }\n"
"    onConnect { _onConnect }\n"
"    serve() { _uv.listen() }\n"
"    stop() { _uv.stop() }\n"
"}\n"
"\n"
"class Connection {\n"
"    static Open { \"open\" }\n"
"    static Closed { \"closed\" }\n"
"\n"
"    construct new(uvconn) {\n"
"        _uv = uvconn\n"
"        _uv.delegate = this\n"
"        _readBuffer = \"\"\n"
"        _readLock = Lock.new()\n"
"        _status = Connection.Open\n"
"    }\n"
"    static connect(ip, port) {\n"
"      var conn = UVConnection.connect(ip,port)\n"
"      return Connection.new(conn)\n"
"    }\n"
"    // status\n"
"    isClosed { _status == Connection.Closed }\n"
"    isOpen { _status == Connection.Open }\n"
"    buffer_ { _readBuffer }\n"
"    uv_ { _uv }\n"
"\n"
"    // output\n"
"    print(data) { _uv.write(\"%(data)\\n\") }\n"
"    write(data) { _uv.write(data) }\n"
"    writeBytes(strData) { _uv.writeBytes(strData) }\n"
"\n"
"    // instantly returns the read buffer or null if there is nothing to read\n"
"    readImmediate() { \n"
"        if (_readBuffer.isEmpty) return null \n"
"        var result = _readBuffer\n"
"        _readBuffer = \"\"\n"
"        return result\n"
"    }\n"
"    // waits for data, then reads the entire buffer\n"
"    readAll() {\n"
"        if (_readBuffer.isEmpty) waitForData()\n"
"        return readImmediate()\n"
"    }\n"
"\n"
"    // TODO: correct behavior when stream is closed?\n"
"    seek(bytes) {\n"
"      var data \n"
"      if (bytes >= _readBuffer.count) {\n"
"        data = _readBuffer\n"
"        _readBuffer = \"\"\n"
"      } else {\n"
"        data = _readBuffer[0...bytes]\n"
"        _readBuffer = _readBuffer[bytes..-1]\n"
"      }\n"
"      return data\n"
"    }\n"
"    // TODO: correct behavior when stream is closed?\n"
"    readBytes(bytes) {\n"
"      while (isOpen && _readBuffer.count < bytes) {\n"
"        waitForData()\n"
"      }\n"
"      return seek(bytes)\n"
"    }\n"
"    readLine() {\n"
"      var lineSeparator\n"
"      while(true) {\n"
"        lineSeparator = _readBuffer.indexOf(\"\\n\")\n"
"        if (lineSeparator != -1) break\n"
"        // TODO: correct behavior when stream is closed?\n"
"        if (isClosed) return null\n"
"        waitForData()\n"
"      }\n"
"      var line = _readBuffer[0...lineSeparator]\n"
"      _readBuffer = _readBuffer[lineSeparator + 1..-1]\n"
"      return line\n"
"    }\n"
"\n"
"    waitForData() { \n"
"      if (isClosed) return\n"
"\n"
"      _readLock.wait() \n"
"    }\n"
"\n"
"    // utility\n"
"    close() { \n"
"        _uv.close() \n"
"        _status = Connection.Closed\n"
"    }\n"
"\n"
"    #delegated\n"
"    dataReceived(data) {\n"
"        if (data==null) { // eof\n"
"          _status = Connection.Closed\n"
"        } else {\n"
"          _readBuffer = _readBuffer + data\n"
"        }\n"
"        _readLock.signal()\n"
"    }\n"
"}\n"
"\n"
"\n"
"\n"
"foreign class UVConnection {\n"
"    construct new() {}\n"
"    static connect(ip, port) {\n"
"      var result = Scheduler.await_ { connect_(ip,port) }\n"
"      if (result is UVConnection) return result\n"
"\n"
"      NetworkError.fromCode(result).raise()\n"
"    }\n"
"    foreign static connect_(ip, port) \n"
"    \n"
"    foreign writeBytes(strData)\n"
"    foreign write(str)\n"
"    foreign close()\n"
"\n"
"    // delegates must provide:\n"
"    // - dataReceived\n"
"    foreign delegate=(d)\n"
"}\n"
"\n"
"foreign class UVServer {\n"
"    construct new(ip,port) {}\n"
"    foreign accept(client)\n"
"    foreign listen()\n"
"    foreign stop()\n"
"\n"
"    // delegates must provide:\n"
"    // - newIncomingConnection\n"
"    foreign delegate=(d)\n"
"}";
